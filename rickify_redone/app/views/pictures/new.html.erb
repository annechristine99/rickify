<h1>New Picture</h1>

<%= render 'form', picture: @picture %>

<%= link_to 'Back', pictures_path %>



<!-- $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ -->


<div id="direct_upload">
  <h1>New picture</h1>
  <h2>Direct upload from the browser<% if @unsigned %>. Unsigned upload using a preset<% end %></h2>
  <%= form_for(@picture, :url => pictures_path) do |f| %>
      <%= f.label :image, "Image:" %>
          <%= link_to("Upload", "#", :class => "upload_button") %>
          <% if @unsigned %>
            <%= f.cl_unsigned_image_upload(:image_id, @preset_name) %>
          <% else %>
            <%= f.cl_image_upload(:image_id, :return_delete_token=>true) %>
          <% end %>
        <%= f.submit "Submit picture" %>
        <% if @error %><span class="error"><%= @error %></span><% end %>
  <% end %>
<canvas id = "myCanvas"></canvas>
<p class="status">Ready to upload!</p>
<!-- <a href="<%= pictures_path %>" class="back_link">Back to list</a> -->

<div id="info"></div>

<!-- Configure Cloudinary jQuery plugin -->
<%= cloudinary_js_config %>

<script>
  $(document).ready(function() {
    // Cloudinary jQuery integration library uses jQuery File Upload widget
    // (see http://blueimp.github.io/jQuery-File-Upload/).
    // Any file input field with cloudinary-fileupload class is automatically
    // wrapped using the File Upload widget and configured for Cloudinary uploads.
    // You can further customize the configuration using .fileupload method
    // as we do below.

    // image_url_to_frs(data.result.bytes)
    // $('input[type=file]').on('change', fileUpload);



    $(".cloudinary-fileupload")
      .cloudinary_fileupload({
        // Uncomment the following lines to enable client side image resizing and valiation.
        // Make sure cloudinary/processing is included the js file
        //disableImageResize: false,
        //imageMaxWidth: 800,
        //imageMaxHeight: 600,
        //acceptFileTypes: /(\.|\/)(gif|jpe?g|png|bmp|ico)$/i,
        //maxFileSize: 20000000, // 20MB
        start: function (e) {
          $(".status").text("Starting upload...");
        },
        progress: function (e, data) {
          $(".status").text("Uploading... " + Math.round((data.loaded * 100.0) / data.total) + "%");
        },
        fail: function (e, data) {
          $(".status").text("Upload failed");
        }
      })
      .off("cloudinarydone").on("cloudinarydone", function (e, data) {
        image_url_to_frs(data.result.url)
        // image_pubid_to_upload(data.result.public_id, data.result.format, 0)
        // $("#picture_bytes").val(data.result.bytes);

      });
    });


    function image_url_to_frs(address) {
      console.log('frsing image');
      $.ajax({
        "url": "/frs",
        "method": "GET",
        data: {address: address}
      }).done(function(data){
        console.log(data)
        rickifier(data, address)
      })
    }


    // Worse comes to worse, stick an ajax call here to the create path, include data

    function image_pubid_to_upload(address, format, redirtag) {
      console.log('uploading image');
      $.ajax({
        "url": "/pictures/upload",
        "method": "post",
        "data": { "address": address, "format": format, "redirtag": redirtag},
        "success": function(){
          console.log("woo")
        }
      })
    }

    function rickifier(data, address) {
      var c=document.getElementById("myCanvas");
      var ctx=c.getContext("2d");
      $("#myCanvas").attr('width', data.image.width)
      $("#myCanvas").attr('height', data.image.height)
      var imageObj1 = new Image();
      var imageObj2 = new Image();
      imageObj1.setAttribute('crossOrigin', 'anonymous');
      imageObj2.setAttribute('crossOrigin', 'anonymous');
      imageObj1.src = address
      //add check for incorrect image profile
      if (data.faces[0].features.eyes===undefined) {
        var leftEyeX = data.faces[0].features.nose.x*.5
        var leftEyeY = data.faces[0].features.nose.y*.6
        var rightEyeX = data.faces[0].features.nose.x*2
        var rightEyeY = data.faces[0].features.nose.y*.2
        var browWidth = (rightEyeX*1.2)-leftEyeX
        var browHeight = data.faces[0].features.mouth.height*.7
      } else {
        var leftEyeX = data.faces[0].features.eyes[1].x*.95
        var leftEyeY = data.faces[0].features.eyes[1].y-data.faces[0].features.eyes[1].height*.90
        var rightEyeX = data.faces[0].features.eyes[0].x
        var rightEyeY = data.faces[0].features.eyes[0].y-data.faces[0].features.eyes[0].height*.90
        //add similar check for y coordinates
        if(leftEyeX > rightEyeX){
          leftEyeX = data.faces[0].features.eyes[0].x
          rightEyeX = data.faces[0].features.eyes[1].x
        }
        var browWidth = (rightEyeX+data.faces[0].features.eyes[0].width)-leftEyeX*.85
        var browHeight = data.faces[0].features.eyes[0].height
      }

      imageObj1.onload = function() {
        ctx.drawImage(imageObj1, 0, 0);
        imageObj2.src = "http://res.cloudinary.com/ds1rn0ryl/image/upload/v1473438420/hxk8ckcb54waw8e4tcr6.png";
        imageObj2.onload = function() {
          //rotate image before drawing object 2, counter-rotate after
          ctx.drawImage(imageObj2, leftEyeX, leftEyeY, browWidth, browHeight);
          // ctx.drawImage(imageObj2, 350, 250)
          var img = c.toDataURL("image/png");
          $(".cloudinary-fileupload").cloudinary_upload_url(img).off("cloudinarydone").on("cloudinarydone", function(e, data){
            image_pubid_to_upload(data.result.public_id, data.result.format, 1)
          });
          }
        };
       }

</script>
